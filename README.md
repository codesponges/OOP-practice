# OOP-practice
객체지향 개념을 적용한 코드 연습
바리스타, 캐셔, 주문서, 종업원 클래스들과 청소 인터페이스로 구현

순서를 생각해보면
1) 캐셔가 주문을 받는다
2) 주문서가 생성된다
3) 바리스타가 주문서에 맞게 커피를 제조한다

프로그래머는 반복되는 코드를 최소화하고 유지보수 간편화와 프로그램 성능 향상을 위해서 객체를 잘 이용해서 효율적인 코드를 짜야 한다. ( 쉽지 않은 듯 )

캐셔와 바리스타는 종업원 이라는 범주 안에 속한다
Employee 클래스를 만들고 부모 클래스로서 캐셔, 바리스타 클래스에 상속

- 상속 이란,
  부모 클래스의 필드, 생성자, 메서드 모두를 자식 클래스에서 물려받게 된다
  이 과정에서 하위 클래스에서 필요에 맞게 메서드를 수정할 수 있는데 이를, 오버라이드 라고 한다
  비슷한 용어로 오버로딩이 있는데 "오버로딩"은 메서드의 이름은 동일한데 데이터 타입 or 파라미터의 구성이 다른 것을 의미한다
  혼동하지 말자
  

- 인터페이스 란,
반드시 지켜야 하는 규칙으로
몸체 { }가 없는 추상 메서드들을 가진다
그리고 인터페이스를 implements 구현하는 쪽에서는 반드시 모든 추상 메서드를 구현해야 에러가 발생하지 않는다
캐셔와 바리스타는 매장을 청소해야 한다.
세부적인 내용은 달라도 청소 라는 것을 하기 때문에 Cleaning 인터페이스를 만들어서 각각의 클래스에서 구현하도록 설계해보았다


 - 방어 코드, 유효성 검사 코드 란,
 앞서 말했지만 프로그램의 안정성과 효율성을 높이기 위해서는 적절한 메모리 관리 등이 요구된다
 방어 코드, 유효성 검사 코드를 가능한 한 앞쪽에 배치함으로써 프로그램의 안정성과 효율을 향상 시킬 수 있다
 if ~ return 문으로 많이 사용한다


 데이터를 저장할 수 있는 공간에는
 **스택, 힙, static 영역** 이 있다
 그 전에 알아야 할 개념이

 - 데이터 타입
   크게 두 가지가 존재한다
   **원시 타입 / 참조 타입**
   원시 타입은 기본 타입을 의미하고 그 이외의 모든 타입을 참조 타입이라고 한다
   원시 타입은 데이터의 크기가 작기 때문에 스택 공간에 저장되고, 참조 타입은 원시 타입이 합쳐진 것으로 데이터가 크다. 그래서 힙 공간에 저장된다
   다시, 원시 타입은 스택, 참조 타입은 힙 공간에 저장된다
   그런데 이 때 힙 공간에 실제 값이 저장됨과 동시에 실제값이 저장된 힙 공간의 주소값이 스택에 저장된다
   그리고 변수에는 실제값을 담고 있는 힙 공간의 주소값이 저장된다
   예를 들면,
    String [] array = { }; 과 같은 임의의 array 배열이 있다고 했을 때 System.out.println( array )의 출력값은 배열의 원소들이 아닌 골뱅이 + 숫자 로 구성된 힙 공간의 주소값이 출력된다
   기억해야 할 부분은 참조 타입의 경우에 변수에 저장되는 값은 실제값이 아닌 실제값을 담고 있는 힙 공간의 주소값이라는 것!

 

